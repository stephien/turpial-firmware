
.. _program_listing_file_lib_WS_src_FreeRTOS.cpp:

Program Listing for File FreeRTOS.cpp
=====================================

|exhale_lsh| :ref:`Return to documentation for file <file_lib_WS_src_FreeRTOS.cpp>` (``lib/WS/src/FreeRTOS.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
    * FreeRTOS.cpp
    *
    *  Created on: Feb 24, 2017
    *      Author: kolban
    */
   #include "FreeRTOS.h"
   #include "sdkconfig.h"
   #include <freertos/FreeRTOS.h> // Include the base FreeRTOS definitions
   #include <freertos/semphr.h>   // Include the semaphore definitions
   #include <freertos/task.h>     // Include the task definitions
   #include <iomanip>
   #include <sstream>
   #include <string>
   /* #if defined(ARDUINO_ARCH_ESP32) && defined(CONFIG_ARDUHAL_ESP_LOG)
   #include "esp32-hal-log.h"
   #define LOG_TAG ""
   #else */
   #include "esp_log.h"
   static const char* LOG_TAG = "FreeRTOS";
   //#endif
   
   void FreeRTOS::sleep(uint32_t ms)
   {
       ::vTaskDelay(ms / portTICK_PERIOD_MS);
   } // sleep
   
   
   void FreeRTOS::startTask(void task(void*), std::string taskName, void* param, uint32_t stackSize)
   {
       ::xTaskCreate(task, taskName.data(), stackSize, param, 5, NULL);
   } // startTask
   
   
   void FreeRTOS::deleteTask(TaskHandle_t pTask)
   {
       ::vTaskDelete(pTask);
   } // deleteTask
   
   
   uint32_t FreeRTOS::getTimeSinceStart()
   {
       return (uint32_t)(xTaskGetTickCount() * portTICK_PERIOD_MS);
   } // getTimeSinceStart
   
   
   uint32_t FreeRTOS::Semaphore::wait(std::string owner)
   {
       ESP_LOGV(LOG_TAG, ">> wait: Semaphore waiting: %s for %s", toString().c_str(), owner.c_str());
   
       m_owner = owner;
   
       if (m_usePthreads) {
           pthread_mutex_lock(&m_pthread_mutex);
       } else {
           xSemaphoreTake(m_semaphore, portMAX_DELAY);
       }
   
       if (m_usePthreads) {
           pthread_mutex_unlock(&m_pthread_mutex);
       } else {
           xSemaphoreGive(m_semaphore);
       }
   
       ESP_LOGV(LOG_TAG, "<< wait: Semaphore released: %s", toString().c_str());
       return m_value;
   } // wait
   
   
   FreeRTOS::Semaphore::Semaphore(std::string name)
   {
       m_usePthreads = false; // Are we using pThreads or FreeRTOS?
       if (m_usePthreads) {
           pthread_mutex_init(&m_pthread_mutex, nullptr);
       } else {
           m_semaphore = xSemaphoreCreateBinary();
           xSemaphoreGive(m_semaphore);
       }
   
       m_name = name;
       m_owner = std::string("<N/A>");
       m_value = 0;
   }
   
   
   FreeRTOS::Semaphore::~Semaphore()
   {
       if (m_usePthreads) {
           pthread_mutex_destroy(&m_pthread_mutex);
       } else {
           vSemaphoreDelete(m_semaphore);
       }
   }
   
   
   void FreeRTOS::Semaphore::give()
   {
       ESP_LOGV(LOG_TAG, "Semaphore giving: %s", toString().c_str());
       if (m_usePthreads) {
           pthread_mutex_unlock(&m_pthread_mutex);
       } else {
           xSemaphoreGive(m_semaphore);
       }
       // #ifdef ARDUINO_ARCH_ESP32
       //  FreeRTOS::sleep(10);
       // #endif
   
       m_owner = std::string("<N/A>");
   } // Semaphore::give
   
   
   void FreeRTOS::Semaphore::give(uint32_t value)
   {
       m_value = value;
       give();
   } // give
   
   
   void FreeRTOS::Semaphore::giveFromISR()
   {
       BaseType_t higherPriorityTaskWoken;
       if (m_usePthreads) {
           assert(false);
       } else {
           xSemaphoreGiveFromISR(m_semaphore, &higherPriorityTaskWoken);
       }
   } // giveFromISR
   
   
   bool FreeRTOS::Semaphore::take(std::string owner)
   {
       ESP_LOGD(LOG_TAG, "Semaphore taking: %s for %s", toString().c_str(), owner.c_str());
       bool rc = false;
       if (m_usePthreads) {
           pthread_mutex_lock(&m_pthread_mutex);
       } else {
           rc = ::xSemaphoreTake(m_semaphore, portMAX_DELAY) == pdTRUE;
       }
       m_owner = owner;
       if (rc) {
           ESP_LOGD(LOG_TAG, "Semaphore taken:  %s", toString().c_str());
       } else {
           ESP_LOGE(LOG_TAG, "Semaphore NOT taken:  %s", toString().c_str());
       }
       return rc;
   } // Semaphore::take
   
   
   bool FreeRTOS::Semaphore::take(uint32_t timeoutMs, std::string owner)
   {
       ESP_LOGV(LOG_TAG, "Semaphore taking: %s for %s", toString().c_str(), owner.c_str());
       bool rc = false;
       if (m_usePthreads) {
           assert(false); // We apparently don't have a timed wait for pthreads.
       } else {
           rc = ::xSemaphoreTake(m_semaphore, timeoutMs / portTICK_PERIOD_MS) == pdTRUE;
       }
       m_owner = owner;
       if (rc) {
           ESP_LOGV(LOG_TAG, "Semaphore taken:  %s", toString().c_str());
       } else {
           ESP_LOGE(LOG_TAG, "Semaphore NOT taken:  %s", toString().c_str());
       }
       return rc;
   } // Semaphore::take
   
   
   std::string FreeRTOS::Semaphore::toString()
   {
       std::stringstream stringStream;
       stringStream << "name: " << m_name << " (0x" << std::hex << std::setfill('0') << (uint32_t)m_semaphore << "), owner: " << m_owner;
       return stringStream.str();
   } // toString
   
   
   void FreeRTOS::Semaphore::setName(std::string name)
   {
       m_name = name;
   } // setName
   
   
   Ringbuffer::Ringbuffer(size_t length, ringbuf_type_t type)
   {
       m_handle = ::xRingbufferCreate(length, type);
   } // Ringbuffer
   
   
   Ringbuffer::~Ringbuffer()
   {
       ::vRingbufferDelete(m_handle);
   } // ~Ringbuffer
   
   
   void* Ringbuffer::receive(size_t* size, TickType_t wait)
   {
       return ::xRingbufferReceive(m_handle, size, wait);
   } // receive
   
   
   void Ringbuffer::returnItem(void* item)
   {
       ::vRingbufferReturnItem(m_handle, item);
   } // returnItem
   
   
   bool Ringbuffer::send(void* data, size_t length, TickType_t wait)
   {
       return ::xRingbufferSend(m_handle, data, length, wait) == pdTRUE;
   } // send
