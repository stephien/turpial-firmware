
.. _program_listing_file_lib_WS_src_GeneralUtils.cpp:

Program Listing for File GeneralUtils.cpp
=========================================

|exhale_lsh| :ref:`Return to documentation for file <file_lib_WS_src_GeneralUtils.cpp>` (``lib/WS/src/GeneralUtils.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
    * GeneralUtils.cpp
    *
    *  Created on: May 20, 2017
    *      Author: kolban
    */
   
   #include "GeneralUtils.h"
   #include "FreeRTOS.h"
   #include <esp_err.h>
   #include <esp_heap_caps.h>
   #include <esp_system.h>
   #include <esp_wifi.h>
   #include <iomanip>
   #include <nvs.h>
   #include <sstream>
   #include <stdio.h>
   #include <string.h>
   #include <string>
   
   #if defined(ARDUINO_ARCH_ESP32) && defined(CONFIG_ARDUHAL_ESP_LOG)
   #include "esp32-hal-log.h"
   #define LOG_TAG ""
   #else
   #include "esp_log.h"
   static const char* LOG_TAG = "GeneralUtils";
   #endif
   
   
   static const char kBase64Alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                                         "abcdefghijklmnopqrstuvwxyz"
                                         "0123456789+/";
   
   static int base64EncodedLength(size_t length)
   {
       return (length + 2 - ((length + 2) % 3)) / 3 * 4;
   } // base64EncodedLength
   
   
   static int base64EncodedLength(const std::string& in)
   {
       return base64EncodedLength(in.length());
   } // base64EncodedLength
   
   
   static void a3_to_a4(unsigned char* a4, unsigned char* a3)
   {
       a4[0] = (a3[0] & 0xfc) >> 2;
       a4[1] = ((a3[0] & 0x03) << 4) + ((a3[1] & 0xf0) >> 4);
       a4[2] = ((a3[1] & 0x0f) << 2) + ((a3[2] & 0xc0) >> 6);
       a4[3] = (a3[2] & 0x3f);
   } // a3_to_a4
   
   
   static void a4_to_a3(unsigned char* a3, unsigned char* a4)
   {
       a3[0] = (a4[0] << 2) + ((a4[1] & 0x30) >> 4);
       a3[1] = ((a4[1] & 0xf) << 4) + ((a4[2] & 0x3c) >> 2);
       a3[2] = ((a4[2] & 0x3) << 6) + a4[3];
   } // a4_to_a3
   
   
   bool GeneralUtils::base64Encode(const std::string& in, std::string* out)
   {
       int i = 0, j = 0;
       size_t enc_len = 0;
       unsigned char a3[3];
       unsigned char a4[4];
   
       out->resize(base64EncodedLength(in));
   
       int input_len = in.size();
       std::string::const_iterator input = in.begin();
   
       while (input_len--) {
           a3[i++] = *(input++);
           if (i == 3) {
               a3_to_a4(a4, a3);
   
               for (i = 0; i < 4; i++) {
                   (*out)[enc_len++] = kBase64Alphabet[a4[i]];
               }
   
               i = 0;
           }
       }
   
       if (i) {
           for (j = i; j < 3; j++) {
               a3[j] = '\0';
           }
   
           a3_to_a4(a4, a3);
   
           for (j = 0; j < i + 1; j++) {
               (*out)[enc_len++] = kBase64Alphabet[a4[j]];
           }
   
           while ((i++ < 3)) {
               (*out)[enc_len++] = '=';
           }
       }
   
       return (enc_len == out->size());
   } // base64Encode
   
   
   void GeneralUtils::dumpInfo()
   {
       size_t freeHeap = heap_caps_get_free_size(MALLOC_CAP_8BIT);
       esp_chip_info_t chipInfo;
       esp_chip_info(&chipInfo);
       ESP_LOGV(LOG_TAG, "--- dumpInfo ---");
       ESP_LOGV(LOG_TAG, "Free heap: %d", freeHeap);
       ESP_LOGV(LOG_TAG, "Chip Info: Model: %d, cores: %d, revision: %d", chipInfo.model, chipInfo.cores, chipInfo.revision);
       ESP_LOGV(LOG_TAG, "ESP-IDF version: %s", esp_get_idf_version());
       ESP_LOGV(LOG_TAG, "---");
   } // dumpInfo
   
   
   bool GeneralUtils::endsWith(std::string str, char c)
   {
       if (str.empty()) {
           return false;
       }
       if (str.at(str.length() - 1) == c) {
           return true;
       }
       return false;
   } // endsWidth
   
   
   static int DecodedLength(const std::string& in)
   {
       int numEq = 0;
       int n = (int)in.size();
   
       for (std::string::const_reverse_iterator it = in.rbegin(); *it == '='; ++it) {
           ++numEq;
       }
       return ((6 * n) / 8) - numEq;
   } // DecodedLength
   
   
   static unsigned char b64_lookup(unsigned char c)
   {
       if (c >= 'A' && c <= 'Z') return c - 'A';
       if (c >= 'a' && c <= 'z') return c - 71;
       if (c >= '0' && c <= '9') return c + 4;
       if (c == '+') return 62;
       if (c == '/') return 63;
       return 255;
   }; // b64_lookup
   
   
   bool GeneralUtils::base64Decode(const std::string& in, std::string* out)
   {
       int i = 0, j = 0;
       size_t dec_len = 0;
       unsigned char a3[3];
       unsigned char a4[4];
   
       int input_len = in.size();
       std::string::const_iterator input = in.begin();
   
       out->resize(DecodedLength(in));
   
       while (input_len--) {
           if (*input == '=') {
               break;
           }
   
           a4[i++] = *(input++);
           if (i == 4) {
               for (i = 0; i < 4; i++) {
                   a4[i] = b64_lookup(a4[i]);
               }
   
               a4_to_a3(a3, a4);
   
               for (i = 0; i < 3; i++) {
                   (*out)[dec_len++] = a3[i];
               }
   
               i = 0;
           }
       }
   
       if (i) {
           for (j = i; j < 4; j++) {
               a4[j] = '\0';
           }
   
           for (j = 0; j < 4; j++) {
               a4[j] = b64_lookup(a4[j]);
           }
   
           a4_to_a3(a3, a4);
   
           for (j = 0; j < i - 1; j++) {
               (*out)[dec_len++] = a3[j];
           }
       }
   
       return (dec_len == out->size());
   } // base64Decode
   
   
   void GeneralUtils::hexDump(const uint8_t* pData, uint32_t length)
   {
       char ascii[80];
       char hex[80];
       char tempBuf[80];
       uint32_t lineNumber = 0;
   
       ESP_LOGV(LOG_TAG, "     00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f");
       ESP_LOGV(LOG_TAG, "     -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --");
       strcpy(ascii, "");
       strcpy(hex, "");
       uint32_t index = 0;
       while (index < length) {
           sprintf(tempBuf, "%.2x ", pData[index]);
           strcat(hex, tempBuf);
           if (isprint(pData[index])) {
               sprintf(tempBuf, "%c", pData[index]);
           } else {
               sprintf(tempBuf, ".");
           }
           strcat(ascii, tempBuf);
           index++;
           if (index % 16 == 0) {
               ESP_LOGV(LOG_TAG, "%.4x %s %s", lineNumber * 16, hex, ascii);
               strcpy(ascii, "");
               strcpy(hex, "");
               lineNumber++;
           }
       }
       if (index % 16 != 0) {
           while (index % 16 != 0) {
               strcat(hex, "   ");
               index++;
           }
           ESP_LOGV(LOG_TAG, "%.4x %s %s", lineNumber * 16, hex, ascii);
       }
   } // hexDump
   
   
   std::string GeneralUtils::ipToString(uint8_t* ip)
   {
       std::stringstream s;
       s << (int)ip[0] << '.' << (int)ip[1] << '.' << (int)ip[2] << '.' << (int)ip[3];
       return s.str();
   } // ipToString
   
   
   std::vector<std::string> GeneralUtils::split(std::string source, char delimiter)
   {
       // See also: https://stackoverflow.com/questions/5167625/splitting-a-c-stdstring-using-tokens-e-g
       std::vector<std::string> strings;
       std::istringstream iss(source);
       std::string s;
       while (std::getline(iss, s, delimiter)) {
           strings.push_back(trim(s));
       }
       return strings;
   } // split
   
   
   const char* GeneralUtils::errorToString(esp_err_t errCode)
   {
       switch (errCode) {
   #if CONFIG_LOG_DEFAULT_LEVEL > 4
       case ESP_OK:
           return "ESP_OK";
       case ESP_FAIL:
           return "ESP_FAIL";
       case ESP_ERR_NO_MEM:
           return "ESP_ERR_NO_MEM";
       case ESP_ERR_INVALID_ARG:
           return "ESP_ERR_INVALID_ARG";
       case ESP_ERR_INVALID_SIZE:
           return "ESP_ERR_INVALID_SIZE";
       case ESP_ERR_INVALID_STATE:
           return "ESP_ERR_INVALID_STATE";
       case ESP_ERR_NOT_FOUND:
           return "ESP_ERR_NOT_FOUND";
       case ESP_ERR_NOT_SUPPORTED:
           return "ESP_ERR_NOT_SUPPORTED";
       case ESP_ERR_TIMEOUT:
           return "ESP_ERR_TIMEOUT";
       case ESP_ERR_NVS_NOT_INITIALIZED:
           return "ESP_ERR_NVS_NOT_INITIALIZED";
       case ESP_ERR_NVS_NOT_FOUND:
           return "ESP_ERR_NVS_NOT_FOUND";
       case ESP_ERR_NVS_TYPE_MISMATCH:
           return "ESP_ERR_NVS_TYPE_MISMATCH";
       case ESP_ERR_NVS_READ_ONLY:
           return "ESP_ERR_NVS_READ_ONLY";
       case ESP_ERR_NVS_NOT_ENOUGH_SPACE:
           return "ESP_ERR_NVS_NOT_ENOUGH_SPACE";
       case ESP_ERR_NVS_INVALID_NAME:
           return "ESP_ERR_NVS_INVALID_NAME";
       case ESP_ERR_NVS_INVALID_HANDLE:
           return "ESP_ERR_NVS_INVALID_HANDLE";
       case ESP_ERR_NVS_REMOVE_FAILED:
           return "ESP_ERR_NVS_REMOVE_FAILED";
       case ESP_ERR_NVS_KEY_TOO_LONG:
           return "ESP_ERR_NVS_KEY_TOO_LONG";
       case ESP_ERR_NVS_PAGE_FULL:
           return "ESP_ERR_NVS_PAGE_FULL";
       case ESP_ERR_NVS_INVALID_STATE:
           return "ESP_ERR_NVS_INVALID_STATE";
       case ESP_ERR_NVS_INVALID_LENGTH:
           return "ESP_ERR_NVS_INVALID_LENGTH";
       case ESP_ERR_WIFI_NOT_INIT:
           return "ESP_ERR_WIFI_NOT_INIT";
       //case ESP_ERR_WIFI_NOT_START:
       //  return "ESP_ERR_WIFI_NOT_START";
       case ESP_ERR_WIFI_IF:
           return "ESP_ERR_WIFI_IF";
       case ESP_ERR_WIFI_MODE:
           return "ESP_ERR_WIFI_MODE";
       case ESP_ERR_WIFI_STATE:
           return "ESP_ERR_WIFI_STATE";
       case ESP_ERR_WIFI_CONN:
           return "ESP_ERR_WIFI_CONN";
       case ESP_ERR_WIFI_NVS:
           return "ESP_ERR_WIFI_NVS";
       case ESP_ERR_WIFI_MAC:
           return "ESP_ERR_WIFI_MAC";
       case ESP_ERR_WIFI_SSID:
           return "ESP_ERR_WIFI_SSID";
       case ESP_ERR_WIFI_PASSWORD:
           return "ESP_ERR_WIFI_PASSWORD";
       case ESP_ERR_WIFI_TIMEOUT:
           return "ESP_ERR_WIFI_TIMEOUT";
       case ESP_ERR_WIFI_WAKE_FAIL:
           return "ESP_ERR_WIFI_WAKE_FAIL";
   #endif
       default:
           return "Unknown ESP_ERR error";
       }
   } // errorToString
   
   const char* GeneralUtils::wifiErrorToString(uint8_t errCode)
   {
       if (errCode == ESP_OK) return "ESP_OK (received SYSTEM_EVENT_STA_GOT_IP event)";
       if (errCode == UINT8_MAX) return "Not Connected (default value)";
   
       switch ((wifi_err_reason_t)errCode) {
   #if CONFIG_LOG_DEFAULT_LEVEL > 4
       case WIFI_REASON_UNSPECIFIED:
           return "WIFI_REASON_UNSPECIFIED";
       case WIFI_REASON_AUTH_EXPIRE:
           return "WIFI_REASON_AUTH_EXPIRE";
       case WIFI_REASON_AUTH_LEAVE:
           return "WIFI_REASON_AUTH_LEAVE";
       case WIFI_REASON_ASSOC_EXPIRE:
           return "WIFI_REASON_ASSOC_EXPIRE";
       case WIFI_REASON_ASSOC_TOOMANY:
           return "WIFI_REASON_ASSOC_TOOMANY";
       case WIFI_REASON_NOT_AUTHED:
           return "WIFI_REASON_NOT_AUTHED";
       case WIFI_REASON_NOT_ASSOCED:
           return "WIFI_REASON_NOT_ASSOCED";
       case WIFI_REASON_ASSOC_LEAVE:
           return "WIFI_REASON_ASSOC_LEAVE";
       case WIFI_REASON_ASSOC_NOT_AUTHED:
           return "WIFI_REASON_ASSOC_NOT_AUTHED";
       case WIFI_REASON_DISASSOC_PWRCAP_BAD:
           return "WIFI_REASON_DISASSOC_PWRCAP_BAD";
       case WIFI_REASON_DISASSOC_SUPCHAN_BAD:
           return "WIFI_REASON_DISASSOC_SUPCHAN_BAD";
       case WIFI_REASON_IE_INVALID:
           return "WIFI_REASON_IE_INVALID";
       case WIFI_REASON_MIC_FAILURE:
           return "WIFI_REASON_MIC_FAILURE";
       case WIFI_REASON_4WAY_HANDSHAKE_TIMEOUT:
           return "WIFI_REASON_4WAY_HANDSHAKE_TIMEOUT";
       case WIFI_REASON_GROUP_KEY_UPDATE_TIMEOUT:
           return "WIFI_REASON_GROUP_KEY_UPDATE_TIMEOUT";
       case WIFI_REASON_IE_IN_4WAY_DIFFERS:
           return "WIFI_REASON_IE_IN_4WAY_DIFFERS";
       case WIFI_REASON_GROUP_CIPHER_INVALID:
           return "WIFI_REASON_GROUP_CIPHER_INVALID";
       case WIFI_REASON_PAIRWISE_CIPHER_INVALID:
           return "WIFI_REASON_PAIRWISE_CIPHER_INVALID";
       case WIFI_REASON_AKMP_INVALID:
           return "WIFI_REASON_AKMP_INVALID";
       case WIFI_REASON_UNSUPP_RSN_IE_VERSION:
           return "WIFI_REASON_UNSUPP_RSN_IE_VERSION";
       case WIFI_REASON_INVALID_RSN_IE_CAP:
           return "WIFI_REASON_INVALID_RSN_IE_CAP";
       case WIFI_REASON_802_1X_AUTH_FAILED:
           return "WIFI_REASON_802_1X_AUTH_FAILED";
       case WIFI_REASON_CIPHER_SUITE_REJECTED:
           return "WIFI_REASON_CIPHER_SUITE_REJECTED";
       case WIFI_REASON_BEACON_TIMEOUT:
           return "WIFI_REASON_BEACON_TIMEOUT";
       case WIFI_REASON_NO_AP_FOUND:
           return "WIFI_REASON_NO_AP_FOUND";
       case WIFI_REASON_AUTH_FAIL:
           return "WIFI_REASON_AUTH_FAIL";
       case WIFI_REASON_ASSOC_FAIL:
           return "WIFI_REASON_ASSOC_FAIL";
       case WIFI_REASON_HANDSHAKE_TIMEOUT:
           return "WIFI_REASON_HANDSHAKE_TIMEOUT";
   #endif
       default:
           return "Unknown ESP_ERR error";
       }
   } // wifiErrorToString
   
   
   std::string GeneralUtils::toLower(std::string& value)
   {
       // Question: Could this be improved with a signature of:
       // std::string& GeneralUtils::toLower(std::string& value)
       std::transform(value.begin(), value.end(), value.begin(), ::tolower);
       return value;
   } // toLower
   
   
   std::string GeneralUtils::trim(const std::string& str)
   {
       size_t first = str.find_first_not_of(' ');
       if (std::string::npos == first) return str;
       size_t last = str.find_last_not_of(' ');
       return str.substr(first, (last - first + 1));
   } // trim
